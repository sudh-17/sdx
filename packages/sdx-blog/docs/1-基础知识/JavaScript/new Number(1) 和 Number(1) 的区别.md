在 JavaScript 中，`new Number(1)` 和 `Number(1)` 之间的主要区别在于它们创建值的类型以及它们的行为。

1. **类型**:


	* `new Number(1)`: 这会创建一个 `Number` 对象。你可以使用 `typeof` 运算符来检查，结果会是 "object"。
	* `Number(1)`: 这会创建一个原始的 `number` 值。使用 `typeof` 检查时，结果会是 "number"。
2. **行为**:


	* 由于 `new Number(1)` 创建的是一个对象，它有一些对象的特性，例如可以附加属性和方法。但通常，我们不建议给原始值类型的包装对象（如 `Number`、`String`、`Boolean`）添加属性或方法，因为这可能会导致意外的行为。
	* `Number(1)` 是一个原始的 `number` 值，它不具有对象的特性。你不能给它添加属性或方法。
3. **性能与内存使用**:


	* 使用 `new Number(1)` 创建的对象通常比使用 `Number(1)` 创建的原始值需要更多的内存，因为对象有额外的开销（例如，存储属性和方法的内存）。
	* 由于 `Number` 对象需要额外的处理（例如，内存分配和垃圾回收），因此在性能上可能不如原始值。
4. **比较**:


	* 当比较两个 `Number` 对象时，即使它们封装了相同的数值，它们也不会相等（因为比较的是引用，而不是值）。
	```javascript
	const a = new Number(1);
	const b = new Number(1);
	console.log(a === b); // 输出 false
	```
	* 当比较两个原始的 `number` 值时，如果它们有相同的数值，则它们是相等的。
	```javascript
	const c = Number(1);
	const d = Number(1);
	console.log(c === d); // 输出 true
	```
5. **自动装箱与拆箱**:


	* 在 JavaScript 中，当需要在需要原始值的地方使用对象时，会发生自动装箱（boxing）。相反，当需要在需要对象的地方使用原始值时，会发生自动拆箱（unboxing）。但这并不意味着你应该依赖这些自动转换，因为它们可能导致代码难以理解和维护。

总的来说，除非你有特定的理由（例如，需要使用某个特定于对象的方法或属性），否则通常建议使用原始的 `number` 值（即 `Number(1)`），而不是 `Number` 对象（即 `new Number(1)`）。